(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{"31Dj":function(e,n,t){"use strict";t.r(n),t.d(n,"SliderPageModule",function(){return T});var i=t("IDUc"),a=t("SVse"),s=t("rk0L"),r=t("s7LF"),o=t("iInd"),l=t("Ci8B"),u=t("8Y7J"),h=t("17Ss"),c=t("2OsT"),p=t("YF55"),m=t("B3dm"),d=function(){return{position:20,text:"low"}},b=function(){return{position:50,text:"medium"}},v=function(){return{position:80,text:"high"}},g=function(e,n,t){return[e,n,t]},S=function(){return[]},f=[{path:"",component:function(){function e(e){this.formService=e,this.importString=t("VqJW"),this.snippet="<sebng-slider></sebng-slider>",this.themeOptions=[{value:"primary",label:"Primary"},{value:"inverted",label:"Inverted"},{value:"success",label:"Success"},{value:"danger",label:"Danger"},{value:"warning",label:"Warning"},{value:"purple",label:"Purple"}],this.value=50,this.step=10,document.title="Slider - SEB Angular Components",this.extendedFormGroup=this.formService.dynamicFormSectionsToFormGroup([{key:"dropdowns",items:[{key:"theme",controlType:"Dropdown",label:"Theme",value:this.themeOptions[0],options:this.themeOptions},{key:"tooltipTheme",controlType:"Dropdown",label:"Tooltip theme",value:this.themeOptions[1],options:this.themeOptions}]},{key:"toggles",items:[{key:"alternative",controlType:"Checkbox",label:"Alternative",description:"Use alternative style of the component.",value:!1},{key:"alwaysShowTooltip",controlType:"Checkbox",label:"Show tooltip",description:"Always show value using tooltip.",value:!1},{key:"disabled",controlType:"Checkbox",label:"Disabled",description:"View the component in disabled state.",value:!1},{key:"useCustomLabels",controlType:"Checkbox",label:"Show custom labels.",value:!1},{key:"showTicks",controlType:"Checkbox",rulerKey:"useCustomLabels",condition:!0,label:"Show ticks",description:"Show ticks with labels",value:!1}]}])}return e.\u0275fac=function(n){return new(n||e)(u.Nb(l.a))},e.\u0275cmp=u.Hb({type:e,selectors:[["app-slider-page"]],features:[u.zb([l.a])],decls:13,vars:26,consts:[[3,"importString"],["example",""],[3,"ngModel","alternative","disabled","step","showTicks","theme","tooltipTheme","labels","alwaysShowTooltip","ngModelChange"],["controls",""],[3,"min","max","ngModel","ngModelChange"],[3,"extendedFormGroup"],["code",""]],template:function(e,n){1&e&&(u.Tb(0,"app-doc-page",0),u.Rb(1,1),u.Tb(2,"sebng-slider",2),u.ac("ngModelChange",function(e){return n.value=e}),u.Sb(),u.Qb(),u.Rb(3,3),u.Tb(4,"label"),u.Hc(5,"Value"),u.Sb(),u.Tb(6,"sebng-stepper",4),u.ac("ngModelChange",function(e){return n.value=e}),u.Sb(),u.Tb(7,"label"),u.Hc(8,"Step"),u.Sb(),u.Tb(9,"sebng-stepper",4),u.ac("ngModelChange",function(e){return n.step=e}),u.Sb(),u.Ob(10,"app-dynamic-form",5),u.Qb(),u.Rb(11,6),u.Hc(12),u.Qb(),u.Sb()),2&e&&(u.mc("importString",n.importString),u.Ab(2),u.mc("ngModel",n.value)("alternative",n.extendedFormGroup.value.toggles.alternative)("disabled",n.extendedFormGroup.value.toggles.disabled)("step",n.step)("showTicks",n.extendedFormGroup.value.toggles.showTicks)("theme",n.extendedFormGroup.value.dropdowns.theme.value)("tooltipTheme",n.extendedFormGroup.value.dropdowns.tooltipTheme.value)("labels",n.extendedFormGroup.value.toggles.useCustomLabels?u.sc(21,g,u.pc(18,d),u.pc(19,b),u.pc(20,v)):u.pc(25,S))("alwaysShowTooltip",n.extendedFormGroup.value.toggles.alwaysShowTooltip),u.Ab(4),u.mc("min",0)("max",100)("ngModel",n.value),u.Ab(3),u.mc("min",0)("max",100)("ngModel",n.step),u.Ab(1),u.mc("extendedFormGroup",n.extendedFormGroup),u.Ab(2),u.Ic(n.snippet))},directives:[h.a,c.a,r.l,r.n,p.a,m.a],encapsulation:2}),e}()}],y=function(){function e(){}return e.\u0275mod=u.Lb({type:e}),e.\u0275inj=u.Kb({factory:function(n){return new(n||e)},imports:[[o.i.forChild(f)],o.i]}),e}(),T=function(){function e(){}return e.\u0275mod=u.Lb({type:e}),e.\u0275inj=u.Kb({factory:function(n){return new(n||e)},imports:[[a.c,y,r.h,s.a,i.a,r.s]]}),e}()},VqJW:function(e,n,t){"use strict";t.r(n),n.default='import {\n    Input,\n    EventEmitter,\n    Output,\n    OnInit,\n    OnChanges,\n    SimpleChanges,\n    ViewEncapsulation,\n    Component,\n    forwardRef,\n    Provider,\n    ChangeDetectorRef,\n    AfterContentChecked,\n    HostBinding,\n} from "@angular/core";\nimport { ControlValueAccessor, NG_VALUE_ACCESSOR } from "@angular/forms";\n\nexport type SliderTheme = "primary" | "inverted" | "success" | "danger" | "warning" | "purple";\nexport type SliderAppearance = "normal" | "alternative";\nexport interface RangeSliderLabel {\n    position: number;\n    text: string;\n}\n\ntype AppearanceStyleMap = {\n    [key in SliderAppearance]: {\n        width: string;\n        offset: string;\n    };\n};\n\nconst CUSTOM_SLIDER_CONTROL_VALUE_ACCESSOR: Provider = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => SliderComponent),\n    multi: true,\n};\n\n/** A slider to experiment and adjust values with. */\n@Component({\n    selector: "sebng-slider",\n    templateUrl: "./slider.component.html",\n    styleUrls: ["./slider.component.scss"],\n    encapsulation: ViewEncapsulation.None,\n    providers: [CUSTOM_SLIDER_CONTROL_VALUE_ACCESSOR],\n})\nexport class SliderComponent implements OnInit, OnChanges, AfterContentChecked, ControlValueAccessor {\n    /** Use an alternative version of the slider */\n    @Input() alternative?: boolean;\n    /** Always Show tooltip (default: false) */\n    @Input() alwaysShowTooltip?: boolean;\n    /** Element class name */\n    @Input() className?: string;\n    /** Property sets whether slider is disabled */\n    @Input() disabled?: boolean;\n    /** Error message of slider */\n    @Input() error?: string;\n    /** Element ID */\n    @Input() id?: string;\n    /** Element label */\n    @Input() label?: string;\n    /** Labels to be displayed below the slider */\n    @Input() labels?: Array<RangeSliderLabel>;\n    /** Maximum value of the range */\n    @Input() max?: number;\n    /** Minimum value of the range */\n    @Input() min?: number;\n    /** Slider name */\n    @Input() name: string;\n    /** Callback on slider value change */\n    @Output() onChange: EventEmitter<number> = new EventEmitter<number>();\n    /** Show ticks with labels (default: false) */\n    @Input() showTicks?: boolean;\n    /** Value changes on every increment/decrement */\n    @Input() step?: number;\n    /** Slider theme based on SEB predefined colors. (default: \'primary\') */\n    @Input() theme?: SliderTheme;\n    /** Tooltip theme based on SEB predefined colors. (default: \'inverted\') */\n    @Input() tooltipTheme?: SliderTheme;\n    /** Custom tooltip value */\n    @Input() tooltipValue?: string;\n\n    @HostBinding("style") styles = "width: 100%;";\n\n    private _min: number = 0;\n    private _max: number = 0;\n    private _size: number = 0;\n    private _labelsPositions: Array<string> = [];\n\n    private _appearance: SliderAppearance;\n    private _activeTrackStyles: CSSStyleDeclaration = {} as CSSStyleDeclaration;\n\n    public thumbPosition: number = 0;\n\n    private _value: number;\n\n    private onTouchedCallback: () => void;\n    private onChangeCallback: (_: any) => void;\n\n    private appearanceSizesMap: AppearanceStyleMap = {\n        alternative: { width: "27px", offset: "56px" },\n        normal: { width: "5px", offset: "24px" },\n    };\n\n    constructor(private ref: ChangeDetectorRef) {\n        this.appearance = !!this.alternative ? "alternative" : "normal";\n    }\n\n    get innerMin(): number {\n        return this._min;\n    }\n\n    set innerMin(value: number) {\n        this._min = value;\n        this.setLabelsPositions();\n        this.setStyleTracks();\n    }\n\n    get innerMax(): number {\n        return this._max;\n    }\n\n    set innerMax(value: number) {\n        this._max = value;\n        this.setLabelsPositions();\n        this.setStyleTracks();\n    }\n\n    get size(): number {\n        return this._size;\n    }\n\n    set size(value: number) {\n        this._size = value;\n        this.setStyleTracks();\n    }\n\n    @Input()\n    get appearance(): SliderAppearance {\n        return this._appearance;\n    }\n\n    set appearance(value: SliderAppearance) {\n        this._appearance = value;\n        this.setStyleTracks();\n    }\n\n    get labelsPositions(): Array<string> {\n        return this._labelsPositions;\n    }\n\n    set labelsPositions(value: Array<string>) {\n        this._labelsPositions = value;\n        this.setStyleTracks();\n    }\n\n    get activeTrackStyles(): CSSStyleDeclaration {\n        return this._activeTrackStyles;\n    }\n\n    set activeTrackStyles(value: CSSStyleDeclaration) {\n        this._activeTrackStyles = value;\n    }\n\n    setSliderRange(): void {\n        // Checking if the min or max are not numbers, null value or undefined\n        const minValue: number = typeof this.min !== "number" ? 0 : this.min;\n        const maxValue: number = typeof this.max !== "number" ? 100 : this.max;\n        this.innerMin = minValue;\n        this.innerMax = maxValue;\n\n        this.size = this.getSize(minValue, maxValue);\n    }\n\n    setLabelsPositions(): void {\n        if (this.labels && this.labels.length) {\n            const positions: Array<string> = [];\n            this.labels.map((label: RangeSliderLabel) => {\n                positions.push(this.getLabelPosition(label.position) + "%");\n            });\n            this.labelsPositions = positions;\n        }\n    }\n\n    setStyleTracks(): void {\n        this.thumbPosition = this.getPercentage();\n        this.activeTrackStyles = this.getActiveTrackStyles();\n    }\n\n    /**\n     * Finds the size between two numbers\n     * @param {number} minValue The minimum value\n     * @param {number} maxValue The maximum value\n     * @returns {number} The size\n     */\n    getSize(minValue: number, maxValue: number): number {\n        if (maxValue > minValue) {\n            return maxValue - minValue;\n        } else {\n            // Will calculate the size anyway, but it will show a warning since the min is larger than the max\n            console.warn(`The max value of the slider should be larger than the min value (Max:${this.innerMax}, Min: ${this.innerMin}`);\n            return minValue - maxValue;\n        }\n    }\n    /**\n     * Converts the current value to percentage based on min and max\n     * @returns {number} The precentage\n     */\n    getPercentage(): number {\n        if (this.value <= this.innerMin) {\n            return 0;\n        } else if (this.value >= this.innerMax) {\n            return 100;\n        } else {\n            const distanceFromMin: number = Math.abs(this.value - this.innerMin);\n            return this.size ? (distanceFromMin / this.size) * 100 : 0;\n        }\n    }\n\n    /**\n     * Calculates the styles needed for the active track\n     * @returns {CSSStyleDeclaration} The active track styles object\n     */\n    getActiveTrackStyles(): CSSStyleDeclaration {\n        const calculatedThumbPosition: number = this.getPercentage();\n        let zeroPosition: number;\n        const { width, offset }: AppearanceStyleMap[keyof AppearanceStyleMap] = this.appearanceSizesMap[this.appearance];\n        const style: CSSStyleDeclaration = {} as CSSStyleDeclaration;\n        if (this.innerMin >= 0) {\n            zeroPosition = 0;\n            style.left = `${zeroPosition}%`;\n            style.width = `calc(${calculatedThumbPosition}% + ${width})`;\n        } else if (this.innerMax <= 0) {\n            zeroPosition = 100;\n            style.left = `calc(${zeroPosition}% + ${offset})`;\n            style.width = `calc(${100 - calculatedThumbPosition}% + ${width})`;\n            style.transform = "rotateY(180deg)";\n        } else {\n            if (this.value <= 0) {\n                zeroPosition = this.size ? Math.abs((this.innerMin / this.size) * 100) : 0;\n                style.left = `calc(${zeroPosition}% + ${width})`;\n                style.width = zeroPosition - calculatedThumbPosition + "%";\n                style.transform = "rotateY(180deg)";\n            } else {\n                zeroPosition = this.size ? Math.abs(100 - (this.innerMax / this.size) * 100) : 0;\n                style.left = `calc(${zeroPosition}% + ${width})`;\n                style.width = calculatedThumbPosition - zeroPosition + "%";\n            }\n        }\n        return style;\n    }\n\n    /**\n     * Calculating the position of the label based on it\'s value\n     * @param {number} value The Slider value\n     * @returns {number} The position of the label in percentage\n     */\n    getLabelPosition(value: number): number {\n        if (value >= this.innerMax) {\n            return 100;\n        } else if (value <= this.innerMin) {\n            return 0;\n        }\n        return Math.abs(((value - this.innerMin) / (this.innerMax - this.innerMin)) * 100);\n    }\n\n    /**\n     * Determines whether to enable or disable CSS transitions based on the total amount of steps\n     * This is fix for a performance impact caused by rapidly updating the state when sliding\n     * @var maxNumberOfStepsToAllowTransition represents the maximum number of steps to have the\n     * transitions enabled. Transitions would be disabled when exceeding that number;\n     * @returns {boolean} `True` if it should transition\n     */\n    shouldEnableTransition(): boolean {\n        const maxNumberOfStepsToAllowTransition: number = 30;\n        return this.size / this.step <= maxNumberOfStepsToAllowTransition;\n    }\n\n    @Input()\n    get value(): number {\n        return this._value;\n    }\n\n    set value(v: number) {\n        if (v !== this._value) {\n            this._value = v;\n            this.onChangeCallback && this.onChangeCallback(v);\n            this.onChange && this.onChange.emit(v);\n            this.thumbPosition = this.getPercentage();\n            this.activeTrackStyles = this.getActiveTrackStyles();\n        }\n    }\n\n    // accessor props\n    writeValue(val: number): void {\n        if (val !== this._value) {\n            this._value = val;\n            this.thumbPosition = this.getPercentage();\n            this.activeTrackStyles = this.getActiveTrackStyles();\n        }\n    }\n\n    registerOnChange(fn: () => void): void {\n        this.onChangeCallback = fn;\n    }\n\n    registerOnTouched(fn: () => void): void {\n        this.onTouchedCallback = fn;\n    }\n\n    ngOnInit(): void {\n        this.size = 0;\n        this.labelsPositions = [];\n\n        this.setSliderRange();\n        this.setStyleTracks();\n        this.setLabelsPositions();\n    }\n\n    ngAfterContentChecked(): void {\n        this.ref.detectChanges();\n    }\n\n    ngOnChanges(changes: SimpleChanges): void {\n        if (changes.max || changes.min) {\n            this.setSliderRange();\n            this.thumbPosition = this.getPercentage();\n            this.activeTrackStyles = this.getActiveTrackStyles();\n            this.setLabelsPositions();\n        }\n\n        if (changes.value) {\n            this.setStyleTracks();\n        }\n\n        if (changes.labels) {\n            this.setLabelsPositions();\n        }\n    }\n}\n'}}]);