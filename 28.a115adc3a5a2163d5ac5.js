(window.webpackJsonp=window.webpackJsonp||[]).push([[28],{"9l7F":function(e,n,t){"use strict";t.r(n),n.default='import { Component, Input, forwardRef, Provider, ViewChildren, QueryList, ElementRef, AfterViewChecked } from "@angular/core";\nimport { NG_VALUE_ACCESSOR, ControlValueAccessor } from "@angular/forms";\n\nexport interface RadioGroupItem {\n    /** The label or text to be displayed in the list */\n    label?: string;\n    /**\n     * A Custom template as html string to be used instead of label and description.\n     *\n     * Example: "<b>Hello</b>"\n     */\n    customTemplate?: string;\n    /** optional description to be displayed next to the label */\n    description?: string;\n    /** any value which should be tied to the item */\n    value: any;\n    /** optional disabled flag. Will show the item grayed out and disabled */\n    disabled?: boolean;\n}\n\ninterface UniqueItem {\n    id: string;\n    optionItem: RadioGroupItem;\n    selected: boolean;\n}\n\ninterface DisplayItem extends UniqueItem {\n    className: string;\n}\n\nconst CUSTOM_RADIOGROUP_CONTROL_VALUE_ACCESSOR: Provider = {\n    provide: NG_VALUE_ACCESSOR,\n    useExisting: forwardRef(() => RadioGroupComponent),\n    multi: true,\n};\n\n/** Use radio buttons when users must select one option in a list with exclusive options out of a set of two or more options. Radio buttons are common to use in forms, i.e when you apply for a loan and need to enter "Yes" or "No". */\n@Component({\n    selector: "sebng-radio-group",\n    templateUrl: "./radio-group.component.html",\n    styleUrls: ["./radio-group.component.scss"],\n    providers: [CUSTOM_RADIOGROUP_CONTROL_VALUE_ACCESSOR],\n})\nexport class RadioGroupComponent implements ControlValueAccessor, AfterViewChecked {\n    // TODO: Add support for custom html as well as string labels?\n    /** List of radio group items */\n    @Input("list")\n    set list(value: RadioGroupItem[]) {\n        this._list = value;\n        this._generateHelperArrays();\n    }\n    get list(): RadioGroupItem[] {\n        return this._list;\n    }\n    private _list: RadioGroupItem[];\n    /** Element name */\n    @Input() name?: string;\n    /** Element label */\n    @Input() label?: string;\n    /** Element class name */\n    @Input() className?: string;\n    /** Property sets whether radio group is disabled */\n    @Input() disabled?: boolean = false;\n    /** Property sets whether radio group is condensed */\n    @Input() condensed?: boolean = false;\n    /** Property sets whether radio group is inline */\n    @Input() inline?: boolean = false;\n\n    // Placeholders for the callbacks which are later provided\n    // by the Control Value Accessor\n    private onTouchedCallback: () => void;\n    private onChangeCallback: (_: any) => void;\n\n    private _selectedValue: RadioGroupItem = null;\n\n    set selectedValue(state: RadioGroupItem) {\n        if (state !== this._selectedValue) {\n            this._selectedValue = state;\n            this.onChangeCallback && this.onChangeCallback(state);\n            this.onTouchedCallback && this.onTouchedCallback();\n\n            this._generateHelperArrays();\n        }\n    }\n\n    get selectedValue() {\n        return this._selectedValue;\n    }\n\n    @ViewChildren("radioRefs") radioRefs: QueryList<ElementRef>;\n\n    /** has the currently selected element been focused already */\n    private didFocus: boolean = false;\n\n    ngAfterViewChecked(): void {\n        this.focusCurrentItem();\n    }\n\n    /**\n     * FOCUS CURRENT ITEM:\n     * Find which of the radio buttons is currently selected (if any) and sets it to focus\n     */\n    focusCurrentItem(): void {\n        if (!this.didFocus && this.list && this.list.length) {\n            const currentFocused: number = this.list.findIndex(e => e && this.selectedValue && e.value === this.selectedValue.value);\n            if (currentFocused > -1 && this.radioRefs.toArray()[currentFocused] && this.radioRefs.toArray()[currentFocused].nativeElement) {\n                setTimeout(() => {\n                    this.radioRefs.toArray()[currentFocused].nativeElement?.focus();\n                    this.didFocus = true;\n                }, 0);\n            }\n        }\n    }\n\n    // HELPER ARRAYS\n    /** array of radio-group item elements with a unique id, the original optionItem and calculated selected property */\n    public uniqueList: Array<UniqueItem> = [];\n    /** Array of radio-group item elements which should be displayed in the current render cycle */\n    public displayList: Array<DisplayItem> = [];\n    /** Array of all radio-group item which are currently selected */\n    public selectedList: Array<RadioGroupItem> = [];\n\n    /** internal generate helper array function. Should be run on every change where the helper arrays need to be regenerated */\n    private _generateHelperArrays(): void {\n        this.uniqueList =\n            this.list &&\n            this.list\n                .filter(\n                    (e: RadioGroupItem) =>\n                        e && (e.hasOwnProperty("label") || e.hasOwnProperty("customTemplate")) && e.hasOwnProperty("value")\n                )\n                .map((e: RadioGroupItem, i: number) => {\n                    const id: string = `${e.value}-${i}`;\n                    let selected: boolean = false;\n\n                    if ((this.selectedValue as RadioGroupItem) && e.value === (this.selectedValue as RadioGroupItem).value) {\n                        selected = true;\n                    }\n\n                    return { optionItem: e, id, selected };\n                });\n\n        this.displayList =\n            this.uniqueList &&\n            this.uniqueList.map((e: UniqueItem) => {\n                return {\n                    ...e,\n                    className: `custom-control custom-radio${e.selected ? " selected" : ""}`,\n                };\n            });\n\n        this.selectedList = this.uniqueList && this.uniqueList.filter((e: UniqueItem) => e.selected).map((e: UniqueItem) => e.optionItem);\n    }\n\n    /** Function which handles the logic of setting the non-native onChange prop (and sets the internal selected value as well) */\n    handleOnChange(value: RadioGroupItem): void {\n        this.didFocus = false;\n        this.selectedValue = value;\n    }\n\n    /** Function containing the select radio-group item logic */\n    optionItemSelected(item: RadioGroupItem): void {\n        const newItem: RadioGroupItem = { ...item };\n        this.handleOnChange(newItem);\n    }\n\n    // HELPERS ================================\n    handleItemOnClick(item: DisplayItem): void {\n        // event.preventDefault();\n        this.optionItemSelected(item.optionItem);\n    }\n\n    writeValue(value: any): void {\n        this.selectedValue = value;\n    }\n    registerOnChange(fn: any): void {\n        this.onChangeCallback = fn;\n    }\n    registerOnTouched(fn: any): void {\n        this.onTouchedCallback = fn;\n    }\n}\n'},v3Hv:function(e,n,t){"use strict";t.r(n),t.d(n,"RadioGroupPageModule",function(){return b});var i=t("/wTi"),o=t("SVse"),s=t("rk0L"),a=t("s7LF"),l=t("PGw9"),r=t("iInd"),d=t("8Y7J"),u=t("17Ss"),c=t("kGDe"),p=t("Njz3"),h=[{path:"",component:function(){function e(){this.importString=t("9l7F"),this.snippet='<sebng-radio-group [list]="list"></sebng-radio-group>',this.list=[{value:"1",label:"First",description:"with description"},{value:"2",label:"Second"},{value:"3",label:"Third (disabled)",disabled:!0},{value:"4",customTemplate:"<code>4\ufe0f\u20e3 Fourth (using custom template)</code> \ud83d\ude0a"},{value:"5",label:"Fifth"}],document.title="Radio Group - SEB Angular Components"}return e.prototype.ngOnInit=function(){},e.\u0275fac=function(n){return new(n||e)},e.\u0275cmp=d.Hb({type:e,selectors:[["app-radiogroup-page"]],decls:9,vars:9,consts:[[3,"importString"],["example",""],[3,"list","disabled","condensed","inline"],["controls",""],["label","Inline","description","Show radio buttons inlined.",3,"ngModel","ngModelChange"],["label","Condensed","description","Show radio buttons with less padding in between.",3,"ngModel","ngModelChange"],["label","Disable All","description","Disable all elements in the group.",3,"ngModel","ngModelChange"],["code",""]],template:function(e,n){1&e&&(d.Tb(0,"app-doc-page",0),d.Rb(1,1),d.Ob(2,"sebng-radio-group",2),d.Qb(),d.Rb(3,3),d.Tb(4,"sebng-checkbox",4),d.ac("ngModelChange",function(e){return n.inline=e}),d.Sb(),d.Tb(5,"sebng-checkbox",5),d.ac("ngModelChange",function(e){return n.condensed=e}),d.Sb(),d.Tb(6,"sebng-checkbox",6),d.ac("ngModelChange",function(e){return n.disabled=e}),d.Sb(),d.Qb(),d.Rb(7,7),d.Hc(8),d.Qb(),d.Sb()),2&e&&(d.mc("importString",n.importString),d.Ab(2),d.mc("list",n.list)("disabled",n.disabled)("condensed",n.condensed)("inline",n.inline),d.Ab(2),d.mc("ngModel",n.inline),d.Ab(1),d.mc("ngModel",n.condensed),d.Ab(1),d.mc("ngModel",n.disabled),d.Ab(2),d.Ic(n.snippet))},directives:[u.a,c.a,p.a,a.l,a.n],encapsulation:2}),e}()}],m=function(){function e(){}return e.\u0275mod=d.Lb({type:e}),e.\u0275inj=d.Kb({factory:function(n){return new(n||e)},imports:[[r.i.forChild(h)],r.i]}),e}(),b=function(){function e(){}return e.\u0275mod=d.Lb({type:e}),e.\u0275inj=d.Kb({factory:function(n){return new(n||e)},imports:[[o.c,m,a.h,s.a,i.a,l.a]]}),e}()}}]);